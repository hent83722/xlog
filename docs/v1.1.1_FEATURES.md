# Zyrnix v1.1.1 - New Features Documentation

## Overview

Version 1.1.1 introduces four developer-focused features that enhance Zyrnix's capabilities for production environments:

1. **Regex-Based Log Filtering** - Pattern-based filtering for flexible log control
2. **Dynamic Log Level Changes** - Runtime log level adjustments without restart
3. **Health Check API** - Built-in monitoring and observability
4. **Compression Auto-Tune** - Adaptive compression level optimization

---

## 1. Regex-Based Log Filtering

### Overview

RegexFilter provides pattern-based filtering using regular expressions, enabling flexible control over which log messages are recorded.

### Use Cases

- **Security**: Filter out sensitive data (passwords, tokens, API keys)
- **Debugging**: Focus on specific error patterns or subsystems
- **Performance**: Reduce log volume by filtering noisy messages
- **Compliance**: Ensure sensitive information never reaches logs

### API Reference

```cpp
class RegexFilter : public LogFilter {
public:
    // Constructor for message filtering
    explicit RegexFilter(const std::string& pattern, bool invert = false);
    
    // Constructor for field filtering (structured logging)
    RegexFilter(const std::string& field_name, const std::string& pattern, bool invert = false);
    
    bool should_log(const LogRecord& record) const override;
    std::string pattern() const;
};
```

### Examples

#### Basic Message Filtering

```cpp
#include <Zyrnix/log_filter.hpp>

auto logger = Zyrnix::Logger::create_stdout_logger("app");

// Only log messages containing ERROR or CRITICAL
auto error_filter = std::make_shared<Zyrnix::RegexFilter>("(ERROR|CRITICAL)");
logger->add_filter(error_filter);

logger->info("Starting up");          // Filtered out
logger->error("ERROR: Failed");       // Logged
logger->critical("CRITICAL: Crash");  // Logged
```

#### Inverted Filtering (Exclude Pattern)

```cpp
// Log everything EXCEPT messages containing sensitive keywords
auto no_secrets = std::make_shared<Zyrnix::RegexFilter>(
    "(password|token|secret|key)", 
    true  // invert = true
);
logger->add_filter(no_secrets);

logger->info("User login successful");        // Logged
logger->info("Invalid password attempt");     // Filtered out
logger->debug("API token: xyz123");           // Filtered out
```

#### Field-Based Filtering (Structured Logging)

```cpp
// Only log messages where the "severity" field matches "high" or "critical"
auto severity_filter = std::make_shared<Zyrnix::RegexFilter>(
    "severity", 
    "(high|critical)"
);
logger->add_filter(severity_filter);
```

#### Combining Multiple Filters

```cpp
auto composite = std::make_shared<Zyrnix::CompositeFilter>(
    Zyrnix::CompositeFilter::Mode::AND
);

// Must match ERROR pattern AND not contain sensitive data
composite->add_filter(std::make_shared<Zyrnix::RegexFilter>("ERROR"));
composite->add_filter(std::make_shared<Zyrnix::RegexFilter>("(password|token)", true));

logger->add_filter(composite);
```

### Performance Characteristics

- **Regex Compilation**: One-time cost at filter creation
- **Per-Log Overhead**: 1-5 microseconds per regex check
- **Memory**: ~1 KB per compiled regex pattern
- **Thread Safety**: Filters are thread-safe and lock-free

### Best Practices

1. **Compile Once**: Create filters at initialization, not per log call
2. **Simple Patterns**: Use simple patterns when possible (faster)
3. **Inverted for Exclusion**: Use `invert=true` for blacklist patterns
4. **Test Patterns**: Validate regex patterns before deployment
5. **Combine Wisely**: Use CompositeFilter to combine multiple conditions

---

## 2. Dynamic Log Level Changes

### Overview

Dynamic log level changes allow runtime adjustment of verbosity without application restart, using lock-free atomic operations for high performance.

### Use Cases

- **Production Debugging**: Enable debug logging during incidents
- **Load-Based Adjustment**: Reduce verbosity under high load
- **Configuration Hot-Reload**: Update log levels from config files
- **API Control**: Expose REST endpoints for log level control
- **Testing**: Adjust verbosity dynamically during tests

### API Reference

```cpp
class Logger {
public:
    // Existing methods (still available)
    void set_level(LogLevel level);
    LogLevel get_level() const;
    
    // New in v1.1.1: Dynamic level changes with callbacks
    void set_level_dynamic(LogLevel level);
    void register_level_change_callback(LogLevelChangeCallback callback);
    void clear_level_change_callbacks();
    
    using LogLevelChangeCallback = std::function<void(LogLevel old_level, LogLevel new_level)>;
};
```

### Examples

#### Basic Usage

```cpp
auto logger = Zyrnix::Logger::create_stdout_logger("app");

// Set initial level
logger->set_level(Zyrnix::LogLevel::Info);

// Change level at runtime (thread-safe)
logger->set_level_dynamic(Zyrnix::LogLevel::Debug);

// Debug messages now visible
logger->debug("Debug information");
```

#### With Callbacks

```cpp
// Register callback to track level changes
logger->register_level_change_callback([](LogLevel old_level, LogLevel new_level) {
    std::cout << "Log level changed from " << static_cast<int>(old_level)
              << " to " << static_cast<int>(new_level) << "\n";
    
    // Log to monitoring system
    metrics.record_level_change(old_level, new_level);
});

// Callback will be triggered
logger->set_level_dynamic(LogLevel::Trace);
```

#### Configuration Hot-Reload

```cpp
class ConfigManager {
    void on_config_change(const Config& new_config) {
        // Update log levels from config file
        for (auto& [name, level] : new_config.log_levels) {
            auto logger = get_logger(name);
            if (logger) {
                logger->set_level_dynamic(level);
            }
        }
    }
};
```

#### Conditional Debugging

```cpp
// Enable debug logging based on environment variable
if (std::getenv("DEBUG") != nullptr) {
    logger->set_level_dynamic(LogLevel::Debug);
} else {
    logger->set_level_dynamic(LogLevel::Info);
}

// Or based on system load
double cpu_usage = get_cpu_usage();
if (cpu_usage > 80.0) {
    // Reduce verbosity under high load
    logger->set_level_dynamic(LogLevel::Warn);
} else {
    logger->set_level_dynamic(LogLevel::Debug);
}
```

### Performance Characteristics

- **Read Path**: <10 nanoseconds (lock-free atomic load)
- **Write Path**: ~100 nanoseconds (atomic exchange + callbacks)
- **Memory**: +8 bytes per logger (atomic storage)
- **Thread Safety**: Full thread safety with no contention

### Best Practices

1. **Use set_level_dynamic**: Prefer over `set_level()` for thread safety
2. **Callbacks for Logging**: Log level changes for auditing
3. **Rate Limit Changes**: Don't change levels too frequently (> 1Hz)
4. **Document Levels**: Document what each level means for your app
5. **Default to Info**: Start with Info level in production

---

## 3. Health Check API

### Overview

Built-in health monitoring provides real-time status assessment of logging infrastructure, perfect for SRE practices and observability.

### Use Cases

- **Kubernetes Probes**: Liveness and readiness checks
- **Load Balancers**: Health check endpoints
- **Monitoring Dashboards**: Grafana, Datadog, Prometheus integration
- **Alerting**: Detect logging infrastructure issues
- **Capacity Planning**: Track metrics trends over time

### API Reference

```cpp
// Health status levels
enum class HealthStatus {
    Healthy,      // All systems operational
    Degraded,     // Performance issues
    Unhealthy     // Critical problems
};

// Health check result
struct HealthCheckResult {
    HealthStatus status;
    std::string message;
    // ... metrics and indicators
    
    std::string to_json() const;
    std::string to_string() const;
};

// Health checker
class HealthChecker {
public:
    explicit HealthChecker(const HealthCheckConfig& config = {});
    
    HealthCheckResult check_logger(const Logger& logger, const LogMetrics& metrics) const;
    HealthCheckResult check_metrics(const LogMetrics& metrics, size_t queue_capacity = 10000) const;
    
    void set_config(const HealthCheckConfig& config);
};

// Global registry
class HealthRegistry {
public:
    static HealthRegistry& instance();
    
    void register_logger(const std::string& name, std::shared_ptr<Logger> logger);
    void unregister_logger(const std::string& name);
    
    HealthCheckResult check_logger(const std::string& name) const;
    std::map<std::string, HealthCheckResult> check_all() const;
    
    std::string export_json() const;
    HealthStatus get_overall_status() const;
};
```

### Examples

#### Basic Health Check

```cpp
#include <Zyrnix/log_health.hpp>

auto logger = Zyrnix::Logger::create_stdout_logger("api");
Zyrnix::LogMetrics metrics;

// Perform health check
Zyrnix::HealthChecker checker;
auto result = checker.check_metrics(metrics);

// Check status
if (Zyrnix::HealthChecker::is_healthy(result)) {
    std::cout << "âœ… System healthy\n";
} else {
    std::cout << "âš ï¸ Issues detected: " << result.message << "\n";
}
```

#### REST API Endpoint

```cpp
// HTTP handler for /health endpoint
std::string handle_health_request(const HttpRequest& req) {
    auto logger_name = req.query_param("logger");
    
    if (logger_name.empty()) {
        // Check all loggers
        return Zyrnix::HealthRegistry::instance().export_json();
    } else {
        // Check specific logger
        auto result = Zyrnix::HealthRegistry::instance().check_logger(logger_name);
        return result.to_json();
    }
}

// Example JSON output:
// {
//   "status": "healthy",
//   "message": "All systems operational",
//   "metrics": {
//     "messages_logged": 1000000,
//     "messages_dropped": 50,
//     "errors": 10,
//     ...
//   },
//   "indicators": {
//     "drop_rate": 0.005,
//     "error_rate": 0.00001,
//     ...
//   }
// }
```

#### Custom Health Thresholds

```cpp
Zyrnix::HealthCheckConfig config;
config.max_drop_rate_healthy = 0.005;     // 0.5% drop rate
config.max_drop_rate_degraded = 0.02;     // 2% drop rate
config.max_latency_us_healthy = 5000;     // 5ms
config.max_latency_us_degraded = 20000;   // 20ms

Zyrnix::HealthChecker checker(config);
```

#### Prometheus Integration

```cpp
// Export metrics in Prometheus format
auto metrics = logger->get_metrics();
std::string prom_metrics = metrics.export_prometheus("Zyrnix");

// Combine with health status
auto health = checker.check_metrics(metrics);
if (health.status != Zyrnix::HealthStatus::Healthy) {
    prom_metrics += "Zyrnix_health_status{status=\"degraded\"} 1\n";
}
```

### Health Thresholds (Defaults)

| Metric | Healthy | Degraded | Unhealthy |
|--------|---------|----------|-----------|
| Drop Rate | < 1% | < 5% | â‰¥ 5% |
| Error Rate | < 0.1% | < 1% | â‰¥ 1% |
| Latency | < 10ms | < 50ms | â‰¥ 50ms |
| Queue Usage | < 70% | < 90% | â‰¥ 90% |

### Best Practices

1. **Register Early**: Register loggers at application startup
2. **Custom Thresholds**: Tune thresholds for your workload
3. **Alerting**: Alert on Degraded status, not just Unhealthy
4. **Trends**: Track metrics over time, not just point-in-time
5. **Automate**: Integrate with monitoring systems (Prometheus, Grafana)

---

## 4. Compression Auto-Tune

### Overview

Automatic compression level adjustment based on real-time performance metrics, optimizing the trade-off between compression ratio and CPU usage.

### Use Cases

- **Variable Content**: Adapt to different log content types
- **Resource Optimization**: Balance CPU vs disk usage automatically
- **Long-Running Apps**: Adapt to changing workload patterns
- **Production Systems**: Optimize without manual tuning
- **Cost Reduction**: Minimize storage costs automatically

### API Reference

```cpp
struct CompressionOptions {
    CompressionType type = CompressionType::Gzip;
    int level = 6;
    bool compress_on_rotate = true;
    bool auto_tune = false;  // New in v1.1.1
};

class CompressedFileSink {
public:
    // Enable/disable auto-tune
    void enable_auto_tune(bool enable = true);
    bool is_auto_tune_enabled() const;
    
    // Get current level (may differ from initial if auto-tuned)
    int get_current_compression_level() const;
    
    // Get compression statistics
    CompressionStats get_compression_stats() const;
};
```

### Examples

#### Basic Auto-Tune

```cpp
#include <Zyrnix/sinks/compressed_file_sink.hpp>

Zyrnix::CompressionOptions options;
options.type = Zyrnix::CompressionType::Gzip;
options.level = 6;  // Initial level
options.auto_tune = true;  // Enable auto-tune

auto sink = std::make_shared<Zyrnix::CompressedFileSink>(
    "app.log",
    10 * 1024 * 1024,  // 10 MB rotation
    5,                  // Keep 5 files
    options
);

auto logger = std::make_shared<Zyrnix::Logger>("app");
logger->add_sink(sink);

// Compression level will adjust automatically
// based on compression ratio and speed
```

#### Monitoring Auto-Tune

```cpp
// Check current compression level
std::cout << "Current level: " 
          << sink->get_current_compression_level() << "\n";

// Get detailed statistics
auto stats = sink->get_compression_stats();
std::cout << "Files compressed: " << stats.files_compressed << "\n";
std::cout << "Original size: " << stats.original_bytes << " bytes\n";
std::cout << "Compressed size: " << stats.compressed_bytes << " bytes\n";
std::cout << "Compression ratio: " << stats.compression_ratio << "x\n";
std::cout << "Space saved: " 
          << (100.0 - (100.0 * stats.compressed_bytes / stats.original_bytes)) 
          << "%\n";
```

#### Runtime Control

```cpp
// Start without auto-tune
options.auto_tune = false;
auto sink = std::make_shared<Zyrnix::CompressedFileSink>(..., options);

// Enable later based on system load
if (low_cpu_usage()) {
    sink->enable_auto_tune(true);
} else {
    sink->enable_auto_tune(false);
    // Manually set to fastest level
    options.level = 1;
}
```

### Auto-Tune Algorithm

The auto-tune algorithm adjusts compression level based on:

1. **Compression Ratio**: Original size / Compressed size
2. **Compression Speed**: Bytes per second
3. **Historical Performance**: Averages over multiple rotations

**Decision Logic:**
- **Slow + Good Ratio** â†’ Decrease level (faster compression)
- **Fast + Poor Ratio** â†’ Increase level (better compression)
- **Excellent Ratio** â†’ Try decreasing level (may still be good)
- **Otherwise** â†’ Maintain current level

**Stabilization**: Requires 3+ rotations before making adjustments.

### Performance Characteristics

- **Overhead**: ~100 microseconds per rotation (negligible)
- **Memory**: +80 bytes per sink (tracking state)
- **CPU Impact**: Adjusts compression level to optimize CPU vs ratio
- **Convergence**: Stabilizes after 3-5 rotations typically

### Compression Level Ranges

| Algorithm | Levels | Fast | Balanced | Best |
|-----------|--------|------|----------|------|
| Gzip | 1-9 | 1-2 | 5-6 | 9 |
| Zstd | 1-22 | 1-3 | 5-10 | 15+ |

### Best Practices

1. **Start Balanced**: Begin with level 6 (gzip) or 5 (zstd)
2. **Let It Stabilize**: Wait for 3-5 rotations before evaluating
3. **Monitor Stats**: Track compression ratio and speed trends
4. **Consider Workload**: High CPU load? Disable auto-tune or use lower level
5. **Test First**: Validate on representative log data before production

---

## Migration from v1.1.0

All new features are **fully backward compatible**. No code changes required.

### Recommended Updates

```cpp
// 1. Add regex filtering for sensitive data
auto filter = std::make_shared<Zyrnix::RegexFilter>("(password|token)", true);
logger->add_filter(filter);

// 2. Use atomic log level changes
logger->set_level_dynamic(Zyrnix::LogLevel::Debug);  // Instead of set_level()

// 3. Add health monitoring
Zyrnix::HealthRegistry::instance().register_logger("my_logger", logger);

// 4. Enable compression auto-tune
options.auto_tune = true;
```

---

## Performance Summary

| Feature | Overhead | Memory | Thread Safe |
|---------|----------|--------|-------------|
| Regex Filtering | 1-5 Î¼s/check | ~1 KB/filter | Yes |
| Dynamic Levels | <10 ns/check | +8 bytes | Lock-free |
| Health Checks | 0 (on-demand) | ~500 bytes | Yes |
| Auto-Tune | ~100 Î¼s/rotation | +80 bytes | Yes |

---

## Examples

See [`examples/v1.1.1_features.cpp`](../examples/v1.1.1_features.cpp) for comprehensive demonstrations.

---

## Support

- **Documentation**: See [Release Notes](notes/RELEASE_NOTES_v1.1.1-beta.1.md)
- **Issues**: [GitHub Issues](https://github.com/hent83722/Zyrnix/issues)
- **Examples**: [`examples/`](../examples/) directory

---

**Enjoy the new features! ðŸš€**
