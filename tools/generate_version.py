#!/usr/bin/env python3
"""
generate_version.py - Generate version header and update version numbers.

This script manages version information across the Zyrnix project:
- Generates include/Zyrnix/version.hpp from CMakeLists.txt
- Can bump version numbers (major, minor, patch)
- Updates version in CMakeLists.txt, conanfile.py, and documentation

Usage:
    python tools/generate_version.py              # Generate version header
    python tools/generate_version.py --bump patch # Bump patch version
    python tools/generate_version.py --set 2.0.0  # Set specific version
"""

import argparse
import re
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple


@dataclass
class Version:
    """Semantic version representation."""
    major: int
    minor: int
    patch: int
    prerelease: str = ""
    
    @classmethod
    def parse(cls, version_str: str) -> 'Version':
        """Parse a version string like '1.2.3' or '1.2.3-beta.1'."""
        match = re.match(r'^(\d+)\.(\d+)\.(\d+)(?:-(.+))?$', version_str)
        if not match:
            raise ValueError(f"Invalid version string: {version_str}")
        
        return cls(
            major=int(match.group(1)),
            minor=int(match.group(2)),
            patch=int(match.group(3)),
            prerelease=match.group(4) or ""
        )
    
    def __str__(self) -> str:
        base = f"{self.major}.{self.minor}.{self.patch}"
        if self.prerelease:
            return f"{base}-{self.prerelease}"
        return base
    
    def bump(self, part: str) -> 'Version':
        """Return a new version with the specified part bumped."""
        if part == 'major':
            return Version(self.major + 1, 0, 0)
        elif part == 'minor':
            return Version(self.major, self.minor + 1, 0)
        elif part == 'patch':
            return Version(self.major, self.minor, self.patch + 1)
        else:
            raise ValueError(f"Invalid version part: {part}")


def find_project_root() -> Path:
    """Find the project root by looking for CMakeLists.txt."""
    current = Path(__file__).resolve().parent
    while current != current.parent:
        if (current / 'CMakeLists.txt').exists():
            return current
        current = current.parent
    return Path.cwd()


def get_version_from_cmake(cmake_path: Path) -> Version:
    """Extract version from CMakeLists.txt."""
    content = cmake_path.read_text()
    
    
    match = re.search(r'project\s*\(\s*\w+\s+VERSION\s+([\d.]+(?:-[\w.]+)?)\s*\)', content)
    if match:
        return Version.parse(match.group(1))
    
 
    major = re.search(r'set\s*\(\s*PROJECT_VERSION_MAJOR\s+(\d+)\s*\)', content)
    minor = re.search(r'set\s*\(\s*PROJECT_VERSION_MINOR\s+(\d+)\s*\)', content)
    patch = re.search(r'set\s*\(\s*PROJECT_VERSION_PATCH\s+(\d+)\s*\)', content)
    
    if major and minor and patch:
        return Version(int(major.group(1)), int(minor.group(1)), int(patch.group(1)))
    
    raise ValueError("Could not find version in CMakeLists.txt")


def update_cmake_version(cmake_path: Path, version: Version) -> None:
    """Update version in CMakeLists.txt."""
    content = cmake_path.read_text()
    

    content = re.sub(
        r'(project\s*\(\s*\w+\s+VERSION\s+)[\d.]+(?:-[\w.]+)?(\s*\))',
        rf'\g<1>{version}\2',
        content
    )
    
    cmake_path.write_text(content)
    print(f"Updated: {cmake_path}")


def update_conanfile_version(conan_path: Path, version: Version) -> None:
    """Update version in conanfile.py."""
    if not conan_path.exists():
        return
    
    content = conan_path.read_text()
    
 
    content = re.sub(
        r'(version\s*=\s*["\'])[\d.]+(?:-[\w.]+)?(["\'])',
        rf'\g<1>{version}\2',
        content
    )
    
    conan_path.write_text(content)
    print(f"Updated: {conan_path}")


def generate_version_header(project_root: Path, version: Version) -> None:
    """Generate the version.hpp header file."""
    header_content = f'''#pragma once
/**
 * @file version.hpp
 * @brief Zyrnix version information
 * 
 * Auto-generated by tools/generate_version.py
 * Do not edit manually.
 */

#ifndef XLOG_VERSION_HPP
#define XLOG_VERSION_HPP

/// Zyrnix major version
#define XLOG_VERSION_MAJOR {version.major}

/// Zyrnix minor version
#define XLOG_VERSION_MINOR {version.minor}

/// Zyrnix patch version
#define XLOG_VERSION_PATCH {version.patch}

/// Zyrnix version string
#define XLOG_VERSION_STRING "{version}"

/// Zyrnix version as single integer (major * 10000 + minor * 100 + patch)
#define XLOG_VERSION_NUMBER {version.major * 10000 + version.minor * 100 + version.patch}

/// Check if Zyrnix version is at least the specified version
#define XLOG_VERSION_AT_LEAST(major, minor, patch) \\
    (XLOG_VERSION_NUMBER >= ((major) * 10000 + (minor) * 100 + (patch)))

namespace Zyrnix {{

/// Get the version string at runtime
inline const char* version() noexcept {{
    return XLOG_VERSION_STRING;
}}

/// Get the major version number
inline int version_major() noexcept {{
    return XLOG_VERSION_MAJOR;
}}

/// Get the minor version number
inline int version_minor() noexcept {{
    return XLOG_VERSION_MINOR;
}}

/// Get the patch version number
inline int version_patch() noexcept {{
    return XLOG_VERSION_PATCH;
}}

}} // namespace Zyrnix

#endif // XLOG_VERSION_HPP
'''
    
    version_path = project_root / 'include' / 'Zyrnix' / 'version.hpp'
    version_path.parent.mkdir(parents=True, exist_ok=True)
    version_path.write_text(header_content)
    print(f"Generated: {version_path}")


def main():
    parser = argparse.ArgumentParser(
        description='Generate version header and manage version numbers'
    )
    parser.add_argument('--bump', choices=['major', 'minor', 'patch'],
                        help='Bump the specified version component')
    parser.add_argument('--set', dest='set_version', metavar='VERSION',
                        help='Set a specific version (e.g., 2.0.0)')
    parser.add_argument('--dry-run', action='store_true',
                        help='Show what would be done without making changes')
    
    args = parser.parse_args()
    
    project_root = find_project_root()
    cmake_path = project_root / 'CMakeLists.txt'
    conan_path = project_root / 'conanfile.py'
    
    print(f"Project root: {project_root}")
    
 
    current_version = get_version_from_cmake(cmake_path)
    print(f"Current version: {current_version}")
    
    
    if args.set_version:
        new_version = Version.parse(args.set_version)
    elif args.bump:
        new_version = current_version.bump(args.bump)
    else:
        new_version = current_version
    
    if new_version != current_version:
        print(f"New version: {new_version}")
    
    if args.dry_run:
        print("\nDry run - no files modified")
        return 0
    
  
    if new_version != current_version:
        update_cmake_version(cmake_path, new_version)
        update_conanfile_version(conan_path, new_version)
    
   
    generate_version_header(project_root, new_version)
    
    print(f"\nVersion: {new_version}")
    return 0


if __name__ == '__main__':
    sys.exit(main())
